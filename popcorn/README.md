usage: popcorn.py [-h] [--out-dir OUT_DIR] [--list] [--dry-run] input_file

popcorn / pop
=============

A compilation test expander in the spirit of catch2. Write one template, get
many independent tests!

Note: This documentation should be generated by running `pop --help > README.md`.

Using
-----

This file can be consumed both as a library (called popcorn) and as an
executable (called pop, since it's a verb).

The basic way to use popcorn is to call

```sh
pop in.cpp --out-dir output_directory/
```

This will read `in.cpp` and generate all the test files into the
`output_directory/`.

`pop` won't change any lines - merely either include or exclude them.

Template file syntax
--------------------

### Scopes

`pop`'s model is similar to `catch2`'s. Every line belongs to a (possibly
nested) scope.

```cpp
this line is in global scope
//% case A {
this line is in scope A
    //% case 1 {
    this line is in scope A.1
    //% }
this line is again just in scope A
//% }
```

`pop` uses c++ line comments of the form `//% DIRECTIVE` to inform itself.

There are three ways to do line annotations:

```cpp
a block designator, closed with '//% }'
//% case A {
    // a next-line designator
    //% case ii
    this line is in A.ii
    this line is just in A

    // and a this-line designator
    this line is in A.iv //% case iv
//% }
```

Contexts are normally nested, but they can be entered multiple at a time:

```cpp
//% case A {
//% case iii.blorg
this line is in A.iii.blorg
//% }
```

But if you need an escape just for a line or two, you can name a scope
absolutely with `#`.

```cpp
//% case A.B.C {
just this line in A.ii //% #A.ii
//%
```

This is useful, for instance, if you need to "just add a line" to the preamble
for certain checks:

```cpp
struct foo {
    void bar(); //% case only.need.it.here
};
// ... somewhere later
//% case only.need {
//% case it
foo{}.bar() //% OK here: not present in other checks
//% }
```

### Checks

To actually generate any cases, you need to use one of the two check
directives: `OK` and `error`.

They work in all three scoped ways like above, but the syntax is

```cpp
static_assert(true == true); //% OK: true is true
static_assert(false == true); //% error optional_scope_name
//% case nested {
//% error optional.scope_name: optional description too long for end
static_assert(is_this_true() == true); 
// ^^^ check in nested.optional.scope_name
//% }
//% OK block.check {
// you can also have blocks that are a single check target
static_assert(true);
//% }
```

The above generates 4 test files:

```cpp
static_assert(true == true); //% OK: true is true
```

```cpp
static_assert(false == true); //% error optional_scope_name
```

```cpp
//% case nested {
//% error optional.scope_name: optional description too long for end
static_assert(is_this_true() == true); 
// ^^^ check in nested.optional.scope_name
//% }
```

```cpp
//% OK block.check {
// you can also have blocks that are a single check target
static_assert(true);
//% }
```

Examples
--------

Regenerate the main test suite from `in.cpp`:

```sh
pop tests/in.cpp --out-dir tests/examples
```

Check which targets exist in in.cpp:

```sh
pop tests/in.cpp --list
```

See what would be generated from `in.cpp`:

```sh
pop tests/in.cpp --out-dir tests/examples --dry-run
```

Synopsis
--------

positional arguments:
  input_file         Input file

options:
  -h, --help         show this help message and exit
  --out-dir OUT_DIR  Output directory.
  --list             Just list the targets.
  --dry-run          Instead of writing files, print their names and contents.
